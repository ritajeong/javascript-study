# 26장 ES6 함수의 추가 기능

## 26.1 함수의 구분

<br>

### ES6 이전
- ES6 이전에는 자바스크립트의 함수를 목적에 따라 구분하지 않았다. 
- 하나의 함수가 '일반 함수', '생성자 함수', '메서드'의 역할을 모두 수행했다.
- 즉, ES6 이전의 함수는 callable인 동시에 constructor 였다.
- 이러한 방식은 함수 활용에 있어 자유도를 높이는 한 편 실수의 가능성을 내포한다.
- 함수 객체가 필요하지 않은 프로퍼티나 프로토타입을 갖게 된다.

### ES6
- ES6에서는 함수를 사용 목적에 따라 명확하게 구분한다.
  
<br> 

|ES6 함수 구분|constructor|prototype|super|arguments|
|-|:-:|:-:|:-:|:-:|
|일반 함수|O|O|X|O|
|메서드|X|X|O|O|
|화살표 함수|X|X|X|X|

<br>

## 26.2 메서드

<br>

- ES6에서 메서드는 '메서드 축약 표현'으로 정의된 함수를 의미한다.
- 이후 이 장에서 말하는 메서드는 ES6의 메서드를 의미한다.
- 메서드 축약 표현 예시
  ```js
  const obj = {
    x: 1,
    foo() { // 메서드 축약 표현
      console.log("test");
    },
  }
  ```
- 메서드는 내부 슬롯 [[HomeObject]]를 갖는다.
- 메서드는 super 키워드를 사용할 수 있다.
- [[HomeObject]]와 super에 대한 내용은 `25.8.5` 참고

<br>

## 26.3 화살표 함수

<br>

### 화살표 함수 정의

- 화살표 함수의 기본 정의는 다음과 같다.
  ```js
  (매개변수들) => { 
    함수 몸체 
  }
  ```
- 화살표 함수는 항상 함수 표현식으로 취급된다.
  ```js
  // 변수에 할당
  const multiply = (x, y) => {
    return x * y;
  }

  // 인수로 전달
  someFunc((x, y) => {
    return x * y;
  })
  ```
- 매개변수가 하나라면 소괄호를 생략할 수 있다.
  ```js
  const arrow = x => { console.log(x) };

  // 소괄호는 매개변수가 정확하게 1개일 때만 생략할 수 있다.
  // 따라서 매개변수가 없거나 두개 이상이라면 반드시 소괄호를 적어줘야한다.
  ```
- 함수의 몸체가 하나의 표현식이라면 중괄호를 생략할 수 있다. 이때 해당 표현식을 평가한 값이 암묵적으로 반환된다.
  ```js
  const power = x => x**2;
  
  power(2); // 4
  ```
- 만약 중괄호를 생략한 채로 객체 리터럴을 반환하고 싶다면 반드시 소괄호로 감싸줘야한다. 객체 리터럴을 구성하는 중괄호가 함수 몸체를 감싸는 블록문으로 인식되기 때문이다.
  ```js
  const create = (id, content) => ({ id, content });

  create(1, "test"); // { id: 1, content: "test" }를 반환
  ```

<br>

### 화살표 함수와 일반 함수의 차이

<br>

- 화살표 함수는 non-constructor이다.
- 화살표 함수에서는 중복된 이름의 매개변수를 선언할 수 없다.
  - 이는 strict mode일 때의 함수 선언문과 같다.
- 화살표 함수는 this, arguments, super, new.target을 갖지않는다.
  - 따라서 화살표 함수 내에서 위 키워드를 참조하면 현재 스코프를 제외한 스코프 체인에서 해당 키워드를 탐색한다.
  - 이러한 성질은 콜백 함수를 전달할 때 유용한다.
  - 기존에는 함수가 다른 함수의 인수로 전달될 경우 기존 컨텍스트를 유지하기 까다롭다는 문제점이 있었다.
  - 화살표 함수를 이용하면 다음과 같이 콜백 함수에서도 컨텍스트를 유지할 수 있다.
    ```js
    class A {
      constructor() {
        this.a = null;
      }

      a() {
        this.a = "a";
      }
    }

    class B extends A {
      b() {
        setTimeout(() => {
          console.log(this.a);
          super.a();
          console.log(this.a);
        }, 100)
      }
    }

    const instanceB = new B();

    instanceB.b();
    // null
    // "a"
    ```
  - 위와 같은 성질 중 특히 this만을 꼽아 `Lexical this` 라고 부르기도 하는데 따로 이름을 주는게 의미가 있나 싶다. 다만 ES6 이전에 this가 얼마나 성가신 존재였는지를 나타내는 용어 정도의 의의가 있는 것 같다.

<br>

## 26.4 Rest 파라미터

<br>

- Rest 파라미터는 매개변수의 이름 앞에 ...을 붙여 정의한다.
- Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.

```js
const foo = (...rest) => {
  console.log(rest);
};

foo(1,2,3,4); // [1, 2, 3, 4]
```

- Rest 파라미터는 다른 인자와 함께 사용될 수 있다.
- 이때, 반드시 Rest 파라미터가 마지막이 되어야하며 하나의 함수에서는 하나의 Rest 파라미터만 정의할 수 있다.
- 함수의 인자들에 순차적으로 할당되고 남은 인수들은 모두 Rest 파라미터에게 전달된다.

```js
const foo = (first, second, ...rest) => {
  console.log(first);
  console.log(second);
  console.log(rest);

  foo(1, 2, 3, 4);
  // 1
  // 2
  // [3, 4]
```
- 유사 배열은 arguments 객체와 다르게 배열이라는 장점이 있다.
- arguments 객체를 갖지 않는 화살표 함수에서 가변 인자를 구현하기 위해서는 Rest 파라미터를 사용해야한다.

<br>

## 26.5 매개변수 기본값

- ES6에서는 함수의 인자에 기본값을 지정할 수 있다.
- Rest 파라미터에는 기본값을 지정할 수 없다.

```js
const foo = (x = 0, y = 0) => x + y;

foo(); // 0
// 인자를 전달하지 않았으므로 x, y는 각각 지정한 기본값이 된다.
```