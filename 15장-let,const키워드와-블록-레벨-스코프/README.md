# 15장 let, const 키워드와 블록 레벨 스코프

## 15.1 var 키워드로 선언한 변수의 문제점

<br>

자바스크립트의 `var` 키워드를 통해 선언된 변수는 다른 언어들과는 조금 다른 독특한 성질들을 갖는다. 따라서 다른 언어를 작성하듯 `var` 키워드를 사용하면 여러 문제를 마주할 수 있다. 예컨대 다음과 같은 상황이다.

<br>

1. 변수의 중복 선언을 허용한다.
    - 이미 선언된 변수가 다른 선언에 의해 덮어씌워질 수 있다.
    - 초기화없는 선언의 경우 앞선 선언에 의해 무시될 수 있다.
2. 함수 레벨 스코프를 따른다.
    - 쉽게 말해 실행 컨텍스트 단위로만 스코프가 형성된다고 할 수 있겠다.
    - 이는 하나의 실행 컨텍스트 안에서는 모든 변수가 전역으로 취급된다는 것을 의미한다.
    - <span style="color: #4294F8">개인적으로 특정 언어의 스코프 상 특징은 그 언어를 사용하는 개발자가 충분히 숙지하고 그에 맞게 사용해야할 몫이라고 생각하지만 스코프를 나눌 수단이 함수 하나만으로 제한되는 것은 분명히 불편한 점이다.</span>
3. 호이스팅에 의한 참조
    - 자바스크립트의 변수는 실행컨텍스트가 생성될 때, 즉 런타임 이전에 렉시컬 환경에 등록된다.
    - 특히 var키워드로 생성된 변수는 실행컨텍스트 생성 시 변수 선언과 동시에 초기화 단계가 진행되는데 이때 변수의 값을 undefined로 초기화 한다.
    - 자바스크립트 런타임에서 특정 변수를 사용할 수 있는 지는 변수 초기화 여부에 달렸다. var 키워드로 선언한 변수의 경우 런타임 이전에 초기화를 하기 때문에 런타임에서 변수 선언문 위치와 관계없이 사용할 수 있다. 가령 다음과 같은 상황이 가능해진다.
        ```
        console.log(foo); // undefined
        foo = 123;
        console.log(foo); // 123
        // 변수 선언 전이지만 참조, 할당 모두 가능

        var foo = 1;
        ```

        > **tip!**<br>
        > var 키워드를 사용하더라도 런타임이전에 '할당'을 하지는 않는다.
    - 일반적인 변수 사용에서 선언을 뒤늦게 할 이유가 전혀 없다. 이는 오히려 가독성만 해칠 뿐이다.

이러한 `var`키워드의 문제점을 보완하기위해 ES6에서는 let과 const를 도입했다.

<br>

## 15.2 let 키워드

<br>

`let` 키워드로 선언한 변수는 다음과 같은 특징을 갖는다.

1. 변수 중복을 허용하지 않는다.
    - let키워드를 통해 같은 이름의 변수를 중복 선언하면 SyntaxError가 발생한다.
2. 블록 레벨 스코프를 따른다.
    - 실행 컨텍스트 자체는 기존처럼 실행가능한 코드 단위(전역, 함수, eval)로 생성하지만 블록({}) 구문을 만날 때 마다 새로운 렉시컬 환경을 생성함으로써 블로 스코핑을 구현한다.
3. 코드 상 선언 전에는 참조 할 수 없다.
    - let키워드를 통해 선언된 변수도 호이스팅된다.
    - 그러나 런타임 전에 선언만 될 뿐 초기화 하지는 않는다.
      - 즉, 쓰레기 값이 그대로 남아있는 상태
    - 자바스크립트에서는 초기화 되지 않은 변수를 사용할 수 없기 때문에(js는 쓰레기 값 못참지) reference error가 발생한다.
    - 호이스팅 이후 실제 선언문이 실행될때에서야 초기화가 된다.(undefined)
    - 초기화 되기 전까지 `선언은 되었지만 참조할 수 없는 상태에 있는` 구간을 TDZ(Temporal Dead Zone)이라고 부른다.

    > **tip!**<br>
    > 간혹 let, const로 선언된 변수에 대해 호이스팅되지 않는다고 오해하는 경우가 있다. 이는 호이스팅이 정의상 변수 선언과 초기화를 모두 포함하는 개념임을 전제로한다. 그러나 이런 정의는 다음과 같은 상황을 이해하는데 방해가 된다.
    > ``` 
    > let foo = 1;
    >
    > {
    >   console.log(foo) // ReferenceError!
    >   let foo = 2;
    > }
    > ```
    > 위 코드에서 reference error가 발생한다는 것은 해당 블록 최상단에서 '어떠한 일'이 벌어졌음을 의미한다. 즉, foo 변수의 선언이 '끌어올려'졌다고 보는 것이 타당하다. let 키워드에 의해 끌어올림 현상(호이스팅)이 발생하지 않는다 말하려면 foo가 새로운 선언문을 만나기 전까지 기존 값을 가지고 있어야 자연스럽다. 따라서 호이스팅은 변수의 선언 단계에 한해 이야기 되어져야 한다. 실제로 [ecma-262](https://262.ecma-international.org/11.0/#sec-for-in-and-for-of-statements-runtime-semantics-bindinginitialization) 문서상으로도 hoist되는 현상과 preinitialize되는 현상을 구분한다.
4. 전역 객체의 프로퍼티로 취급되지 않는다.

<br>

## 15.3 const 키워드
const 키워드는 let 키워드의 특징을 상당부분 공유하나 다음과 같은 차이점을 갖는다.

1. 변수의 선언과 초기화(할당)가 동시에 이루어져야한다.
2. 다른 값을 재할당할 수 없다.
    > tip!<br>
    > 재할당이 불가능하다는 특징과 변경이 불가능하다는 특징을 혼동해서는 안된다. const로 선언된 변수에 원시값이 할당되어 있다면 그 값에 대한 변경도 불가능하지만 객체가 할당되어 있을 경우에는 조금 이야기가 다르다. 변수에 할당되어 있는 객체의 주소값은 바뀌지 않겠지만 자바스크립트 객체의 특성인 변경 가능하다는 성질까지 바뀌지는 않는다. 따라서 다음과 같은 상황은 충분히 가능하다.
    > ```
    > const person = {
    >   name: "Lee"
    > };
    >
    > person.name = "Kim";
    > console.log(person); // { name: "Kim" }
    > ```
    >

const 키워드는 상수로 사용할 목적의 값에도 유용하지만 전반적인 변수 선언에 사용하는 것이 좋다. 추후 재할당을 할 '의도'를 가진 변수가 아니라면 불필요한 가능성은 모두 제거하는 편이 안전하기 때문이다.